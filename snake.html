<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic 3D Cube Snake Competition - FPS Slow-Mo</title>
    <style>
        /* ... (CSS remains the same) ... */
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; z-index: 100; display: flex; flex-direction: column; font-size: 11px; text-shadow: 0 0 3px #fff; background-color: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 5px; line-height: 1.4; min-width: 160px; }
        #snake-bars-wrapper { order: 1; margin-bottom: 5px; }
        #game-status { order: 2; }
        .snake-info { margin-bottom: 4px; white-space: nowrap; opacity: 1; transform: scaleY(1); transition: opacity 0.4s ease-out, transform 0.4s ease-out; }
        .snake-label { display: inline-block; width: 70px; vertical-align: middle; overflow: hidden; text-overflow: ellipsis; }
        .length-bar-container { display: inline-block; width: 80px; height: 10px; background-color: #444; border-radius: 3px; overflow: hidden; vertical-align: middle; margin-left: 5px; }
        .length-bar { height: 100%; width: 0%; border-radius: 3px; transition: width 0.3s ease-out; }
        #gameOver { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 101; display: none; font-size: 48px; color: #f00; text-shadow: 0 0 10px #fff; text-align: center; cursor: pointer; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
        #gameOver span { font-size: 20px; display: block; margin-top: 10px; color: #ccc; }
        #eventLog { position: absolute; bottom: 10px; left: 10px; width: 250px; max-height: 150px; overflow-y: hidden; background-color: rgba(0, 0, 0, 0.6); border-radius: 5px; padding: 8px; font-size: 11px; line-height: 1.3; z-index: 99; display: flex; flex-direction: column-reverse; box-shadow: 0 0 10px rgba(255, 255, 255, 0.1); }
        .logEntry { margin-bottom: 3px; opacity: 0; animation: fadeInLog 0.5s ease-out forwards; color: #ccc; text-shadow: 0 0 2px #000; }
        .logEntry:first-child { margin-bottom: 0; } .logEntry.poison { color: #88ff00; } .logEntry.death { color: #ff6666; } .logEntry.achievement { color: #ffff88; } .logEntry.lead { color: #88aaff; } .logEntry.join { color: #aaccaa; }
        @keyframes fadeInLog { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <div id="snake-bars-wrapper"></div>
        <div id="game-status">
            FPS: 0<br>
            Snakes: 0 (+/-)<br>
            Size: 0 [S]<br>
            Food Count: 0<br>
            Poison: Off [K] [Space]<br>
            BG Density: Low [1/2/3]<br>
            Cam Mode: Orbit [C]<br>
            Grid: Off [G]<br>
            Fullscreen: [F]
        </div>
    </div>
    <div id="eventLog"></div>
    <div id="gameOver"> Game Over! <span>Click to Restart</span> </div>

    <!-- Import map -->
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.164.1/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Configuration ---
        const GRID_SIZE = 1;
        const CUBE_SIZES = [16, 24, 32, 64]; let currentCubeSizeIndex = 0; let WORLD_SIZE = CUBE_SIZES[currentCubeSizeIndex]; let WORLD_SIZE_HALF = WORLD_SIZE / 2;
        const GAME_SPEED_MS = 120;
        const MIN_FOOD_TARGET = 2; const MAX_FOOD_TARGET = 5; let currentTargetFoodCount = 3;
        const TARGET_FPS = 120; const MIN_FRAME_TIME = 1 / TARGET_FPS;
        const MIN_SNAKES = 1; const MAX_SNAKES = 8; const GRID_DIVISIONS = 10;
        const SNAKE_COLORS = [ { body: 0x00ff00, head: 0x00ffff }, { body: 0xff8800, head: 0xffff00 }, { body: 0x0088ff, head: 0xaaaaff }, { body: 0xff00ff, head: 0xffaaff }, { body: 0xffffff, head: 0xcccccc }, { body: 0x88ff88, head: 0xeeffee }, { body: 0xffff88, head: 0xffaa00 }, { body: 0x88ffff, head: 0x00aaaa } ];
        const FOOD_COLOR = 0xff00ff; const BOUNDARY_COLOR = 0x555555; const GRID_LINE_COLOR = 0x333333;
        const SHADOW_MAP_SIZE = 1024; const PARTICLE_COUNT = 100; const PARTICLE_SPEED = 5;
        const BLOOM_STRENGTH = 0.5; const BLOOM_RADIUS = 0.3; const BLOOM_THRESHOLD = 0.6;
        const WORLD_ROTATION_SPEED = 0.02;
        const RANDOM_NAMES = ["Alex", "Ben", "Chloe", "David", "Eva", "Finn", "Grace", "Hugo", "Ivy", "Jack", "Kate", "Leo", "Mia", "Noah", "Olivia", "Paul", "Quinn", "Ruby", "Sam", "Tara", "Uma", "Vince", "Willow", "Xavi", "Yara", "Zoe"];
        const POISON_COLOR = 0x88ff00; const RANDOM_POISON_ENABLED_DEFAULT = false; const RANDOM_POISON_INTERVAL_MS = 60000; const RANDOM_POISON_SPAWN_CHANCE = 0.6; const SLOW_MOTION_DURATION_MS = 3000; const SLOW_MOTION_FACTOR = 0.1; const POISON_DEATH_EFFECT_DURATION_MS = 1500;
        const POISON_FOCUS_DURATION_MS = 3000;
        const LENGTH_ACHIEVEMENT_INTERVAL = 15;
        const FPS_CAMERA_SLOWDOWN_FACTOR = 0.5; // <<-- Slowdown for FPS cam (0.5 = 2x slower)

        // --- Camera Effects Config ---
        const CAMERA_MODE_DURATION_BASE = 30; const CAMERA_MODE_DURATION_RANDOM = 8; const CAMERA_TRANSITION_DURATION = 1.5;
        const CAMERA_MODES = ['orbit', 'bRoll', 'panX', 'panZ', 'zoomInOut', 'flyBy', 'fps'];
        let currentCameraMode = 'orbit'; let cameraModeTimer = 0; let cameraModeDuration = CAMERA_MODE_DURATION_BASE;
        let isCameraTransitioning = false; let cameraTransitionTimer = 0; let cameraPreTransitionPos = new THREE.Vector3(); let cameraPreTransitionTarget = new THREE.Vector3(); let cameraTargetPosition = new THREE.Vector3(); let cameraTargetLookAt = new THREE.Vector3(0,0,0); let cameraEffectData = { orbitSpeed: 0.12, startPos: new THREE.Vector3(), endPos: new THREE.Vector3(), startDist: 0, endDist: 0, currentDist: 0, targetSnakeId: -1, }; const _camPos = new THREE.Vector3(); const _camLookAt = new THREE.Vector3(); const _snakeHeadPos = new THREE.Vector3(); const _snakeDir = new THREE.Vector3(); const _idealLookAtFPS = new THREE.Vector3(); const _focusPos = new THREE.Vector3();

        // --- Background Elements ---
        const BG_DENSITY_LEVELS = { low: { stars: 800 * 3, asteroids: 4 * 3, label: "Low"}, medium: { stars: 4000 * 3, asteroids: 20 * 3, label: "Med"}, high: { stars: 8000 * 3, asteroids: 40 * 3, label: "High"} };
        let currentBgDensityLevel = 'low'; let STAR_COUNT = BG_DENSITY_LEVELS[currentBgDensityLevel].stars; let ASTEROID_COUNT = BG_DENSITY_LEVELS[currentBgDensityLevel].asteroids;
        const BACKGROUND_SCALE = 6; let starField = null; let asteroidGroup = null;

        // --- Game State ---
        let scene, camera, renderer, composer, controls, directionalLight;
        let gameWorld; let clock = new THREE.Clock(); let gameTime = 0; let totalTime = 0;
        let frameDeltaAccumulator = 0; let lastFPSTime = 0; let frameCount = 0;
        let snakes = []; let foods = [];
        let isGameOver = false; let gameOverMessage = "Game Over!"; let particles = null; let particleMaterial;
        let worldGrid = null; let boundaryLines = null; let gridVisible = false;
        const aiEnabled = true; let autoCameraEnabled = true; let nextSnakeId = 1;
        let randomPoisonEnabled = RANDOM_POISON_ENABLED_DEFAULT; let lastPoisonSpawnTime = 0; let isSlowMotionActive = false; let slowMotionTimer = 0; let isCameraFocusing = false; let focusedSnakeId = -1;
        let isPausedForFocus = false; let focusPauseTimer = 0; let focusTargetMesh = null; let cameraBeforeFocusPos = new THREE.Vector3(); let cameraBeforeFocusTarget = new THREE.Vector3(); let cameraModeBeforeFocus = 'orbit'; let autoCamEnabledBeforeFocus = true; let isReturningFromFocus = false;
        let currentLeaderId = -1;
        const MAX_LOG_ENTRIES = 10;

        // --- DOM Elements ---
        const infoElement = document.getElementById('info'); const snakeBarsWrapper = document.getElementById('snake-bars-wrapper'); const gameStatusElement = document.getElementById('game-status'); const gameOverElement = document.getElementById('gameOver');
        const eventLogElement = document.getElementById('eventLog');

        // --- Initialization ---
        function init() { /* ... Same setup ... */ scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, CUBE_SIZES[CUBE_SIZES.length - 1] * BACKGROUND_SCALE * 2); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); gameWorld = new THREE.Group(); scene.add(gameWorld); const ambientLight = new THREE.AmbientLight(0xcccccc, 0.7); scene.add(ambientLight); directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = SHADOW_MAP_SIZE; directionalLight.shadow.mapSize.height = SHADOW_MAP_SIZE; directionalLight.shadow.bias = -0.001; scene.add(directionalLight); scene.add(directionalLight.target); controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false; controls.enabled = !autoCameraEnabled; const renderScene = new RenderPass(scene, camera); const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESHOLD); const outputPass = new OutputPass(); composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass); composer.addPass(outputPass); setupParticles(); createSpaceBackground(STAR_COUNT, ASTEROID_COUNT); window.addEventListener('resize', onWindowResize); document.addEventListener('keydown', onUtilityKeyDown); gameOverElement.addEventListener('click', () => resetGame(true)); currentCubeSizeIndex = Math.floor(Math.random() * CUBE_SIZES.length); resetGame(); animate(); }

        // --- Background Creation ---
        function createSpaceBackground(starCount, asteroidCount) { /* ... Same ... */ if (starField) scene.remove(starField); if (asteroidGroup) scene.remove(asteroidGroup); console.log(`Creating background with ${starCount} stars, ${asteroidCount} asteroids.`); const starVertices = []; const starColors = []; const baseColor = new THREE.Color(0xffffff); const starMaterial = new THREE.PointsMaterial({ vertexColors: true, size: 0.15, sizeAttenuation: true, transparent: true, opacity: 0.7, depthWrite: false, blending: THREE.AdditiveBlending }); const starRadius = CUBE_SIZES[CUBE_SIZES.length - 1] * BACKGROUND_SCALE; for (let i = 0; i < starCount; i++) { const theta = Math.random() * Math.PI * 2; const phi = Math.acos((Math.random() * 2) - 1); const r = starRadius * (0.6 + Math.random() * 0.4); starVertices.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); const starColor = baseColor.clone(); starColor.setHSL(Math.random(), 0.10, 0.9); starColors.push(starColor.r, starColor.g, starColor.b); } const starGeometry = new THREE.BufferGeometry(); starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3)); starField = new THREE.Points(starGeometry, starMaterial); starField.renderOrder = -1; scene.add(starField); asteroidGroup = new THREE.Group(); const asteroidMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.8, metalness: 0.1, }); const asteroidFieldRadius = starRadius * 0.7; for (let i = 0; i < asteroidCount; i++) { let asteroidGeom; const type = Math.random(); if (type < 0.6) asteroidGeom = new THREE.IcosahedronGeometry(GRID_SIZE * (0.6 + Math.random() * 1.0), 0); else if (type < 0.85) asteroidGeom = new THREE.DodecahedronGeometry(GRID_SIZE * (0.7 + Math.random() * 0.8), 0); else asteroidGeom = new THREE.BoxGeometry(GRID_SIZE * (0.5 + Math.random()), GRID_SIZE * (0.5 + Math.random()), GRID_SIZE * (0.5 + Math.random())); const asteroid = new THREE.Mesh(asteroidGeom, asteroidMaterial); const theta = Math.random() * Math.PI * 2; const phi = Math.acos((Math.random() * 2) - 1); const r = asteroidFieldRadius * (0.5 + Math.random() * 0.5); asteroid.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)); asteroid.rotation.set(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2); asteroid.userData.rotationSpeed = new THREE.Vector3((Math.random() - 0.5) * 0.005, (Math.random() - 0.5) * 0.005, (Math.random() - 0.5) * 0.005); asteroid.castShadow = false; asteroid.receiveShadow = false; asteroidGroup.add(asteroid); } asteroidGroup.renderOrder = -1; scene.add(asteroidGroup); }

        // --- Grid Creation Helper ---
        function createWorldGridLines(size, divisions) { /* ... Same ... */ const halfSize = size / 2; const step = size / divisions; const vertices = []; for (let j = 0; j <= divisions; j++) { const y = -halfSize + j * step; for (let k = 0; k <= divisions; k++) { const z = -halfSize + k * step; if (j === 0 || j === divisions || k === 0 || k === divisions ) { if (k === 0 || k === divisions) vertices.push(-halfSize, y, z, halfSize, y, z); if (j === 0 || j === divisions) vertices.push(-halfSize, y, z, halfSize, y, z); } else if ( y === 0 || z === 0) { vertices.push(-halfSize, y, z, halfSize, y, z); } } } for (let i = 0; i <= divisions; i++) { const x = -halfSize + i * step; for (let k = 0; k <= divisions; k++) { const z = -halfSize + k * step; if (i === 0 || i === divisions || k === 0 || k === divisions ) { if (k === 0 || k === divisions) vertices.push(x, -halfSize, z, x, halfSize, z); if (i === 0 || i === divisions) vertices.push(x, -halfSize, z, x, halfSize, z); } else if ( x === 0 || z === 0) { vertices.push(x, -halfSize, z, x, halfSize, z); } } } for (let i = 0; i <= divisions; i++) { const x = -halfSize + i * step; for (let j = 0; j <= divisions; j++) { const y = -halfSize + j * step; if (i === 0 || i === divisions || j === 0 || j === divisions ) { if (i === 0 || i === divisions) vertices.push(x, y, -halfSize, x, y, halfSize); if (j === 0 || j === divisions) vertices.push(x, y, -halfSize, x, y, halfSize); } else if ( x === 0 || y === 0) { vertices.push(x, y, -halfSize, x, y, halfSize); } } } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); const material = new THREE.LineBasicMaterial({ color: GRID_LINE_COLOR, transparent: true, opacity: 0.25 }); const lineSegments = new THREE.LineSegments(geometry, material); return lineSegments; }

        // --- Game Logic ---
        function resetGame(forceRandom = false) { /* ... Same ... */ if (forceRandom) { currentCubeSizeIndex = Math.floor(Math.random() * CUBE_SIZES.length); } WORLD_SIZE = CUBE_SIZES[currentCubeSizeIndex]; WORLD_SIZE_HALF = WORLD_SIZE / 2; console.log("Resetting game with world size:", WORLD_SIZE); snakes.forEach(snake => snake.segments.forEach(segment => gameWorld.remove(segment.mesh))); snakes = []; nextSnakeId = 1; foods.forEach(foodItem => gameWorld.remove(foodItem)); foods = []; if (worldGrid) gameWorld.remove(worldGrid); if (boundaryLines) gameWorld.remove(boundaryLines); isGameOver = false; gameOverElement.style.display = 'none'; gameTime = 0; totalTime = 0; gameWorld.rotation.set(0, 0, 0); cameraModeTimer = 0; isCameraTransitioning = false; frameDeltaAccumulator = 0; lastFPSTime = performance.now(); frameCount = 0; gameOverMessage = "Game Over!"; randomPoisonEnabled = RANDOM_POISON_ENABLED_DEFAULT; lastPoisonSpawnTime = performance.now(); isSlowMotionActive = false; slowMotionTimer = 0; isCameraFocusing = false; focusedSnakeId = -1; isPausedForFocus = false; focusPauseTimer = 0; focusTargetMesh = null; isReturningFromFocus = false; currentLeaderId = -1; eventLogElement.innerHTML = ""; const boundaryGeom = new THREE.BoxGeometry(WORLD_SIZE, WORLD_SIZE, WORLD_SIZE); const boundaryEdges = new THREE.EdgesGeometry(boundaryGeom); boundaryLines = new THREE.LineSegments(boundaryEdges, new THREE.LineBasicMaterial({ color: BOUNDARY_COLOR, transparent: true, opacity: 0.5 })); boundaryLines.castShadow = false; boundaryLines.receiveShadow = false; gameWorld.add(boundaryLines); worldGrid = createWorldGridLines(WORLD_SIZE, GRID_DIVISIONS); worldGrid.visible = gridVisible; worldGrid.castShadow = false; worldGrid.receiveShadow = false; gameWorld.add(worldGrid); const camDistFactor = 1.7; camera.position.set(WORLD_SIZE_HALF * camDistFactor, WORLD_SIZE_HALF * (camDistFactor * 0.7), WORLD_SIZE_HALF * camDistFactor); controls.minDistance = WORLD_SIZE_HALF * 0.3; controls.maxDistance = WORLD_SIZE * 3.0; camera.lookAt(0,0,0); controls.target.set(0,0,0); if(scene.fog) { scene.fog.near = WORLD_SIZE * 1.5; scene.fog.far = WORLD_SIZE * 4; } else { scene.fog = new THREE.Fog(0x111111, WORLD_SIZE * 1.5, WORLD_SIZE * 4); } directionalLight.position.set(WORLD_SIZE_HALF * 1.5, WORLD_SIZE_HALF * 2, WORLD_SIZE_HALF * 1.5); const shadowCamSize = WORLD_SIZE_HALF * 1.3; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = WORLD_SIZE * 4; directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize; directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize; directionalLight.shadow.camera.updateProjectionMatrix(); const startSnakeCount = Math.min(Math.floor(Math.random() * 4) + 1, MAX_SNAKES); currentTargetFoodCount = Math.floor(Math.random() * (MAX_FOOD_TARGET - MIN_FOOD_TARGET + 1)) + MIN_FOOD_TARGET; console.log("Target food count:", currentTargetFoodCount); for (let i = 0; i < startSnakeCount; i++) { addSnake(); } manageFoodCount(); switchCameraMode(autoCameraEnabled ? 'orbit' : 'manual'); controls.enabled = !autoCameraEnabled; if (!autoCameraEnabled) { controls.reset(); controls.update(); } updateInfo(); addLogMessage("🚀 Simulation Started!", "achievement"); }

        // --- Snake Management ---
        function addSnake() { /* ... Same ... */ if (snakes.length >= MAX_SNAKES) return; const id = nextSnakeId++; const colorIndex = (id - 1) % SNAKE_COLORS.length; const colors = SNAKE_COLORS[colorIndex]; const name = RANDOM_NAMES[Math.floor(Math.random() * RANDOM_NAMES.length)]; let startPos, startDir, collision; const maxPlacementAttempts = 50; let placementAttempts = 0; const initialLength = 3; do { collision = false; placementAttempts++; const posRange = WORLD_SIZE_HALF * 0.6; startPos = new THREE.Vector3( (Math.random() - 0.5) * 2 * posRange, (Math.random() - 0.5) * 2 * posRange, (Math.random() - 0.5) * 2 * posRange ).floor().multiplyScalar(GRID_SIZE).addScalar(GRID_SIZE/2); const axis = Math.floor(Math.random() * 3); const dirSign = Math.random() < 0.5 ? -1 : 1; startDir = new THREE.Vector3(); startDir.setComponent(axis, dirSign * GRID_SIZE); const tempBodyPos = startPos.clone().sub(startDir); const tempTailPos = tempBodyPos.clone().sub(startDir); for (const existingSnake of snakes) { for (const segment of existingSnake.segments) { if (startPos.distanceToSquared(segment.targetPosition) < (GRID_SIZE * 1.5)**2 || tempBodyPos.distanceToSquared(segment.targetPosition) < (GRID_SIZE * 1.5)**2 || tempTailPos.distanceToSquared(segment.targetPosition) < (GRID_SIZE * 1.5)**2) { collision = true; break; } } if (collision) break; } } while (collision && placementAttempts < maxPlacementAttempts); if (placementAttempts >= maxPlacementAttempts) { startPos = new THREE.Vector3(WORLD_SIZE_HALF - GRID_SIZE, GRID_SIZE/2, GRID_SIZE/2); startDir = new THREE.Vector3(-GRID_SIZE, 0, 0); } const newSnake = { id: id, name: name, segments: [], direction: startDir.clone(), nextDirection: startDir.clone(), color: colors.body, headColor: colors.head, dyingState: { active: false, timer: 0, duration: POISON_DEATH_EFFECT_DURATION_MS }, lastAchievementLength: 0 }; addSnakeSegment(newSnake, startPos.clone(), true); for (let i = 1; i < initialLength; i++) { startPos.sub(newSnake.direction); addSnakeSegment(newSnake, startPos.clone(), false); } snakes.push(newSnake); addLogMessage(`🐍 ${name} joined the game!`, "join"); updateInfo(); checkForLeaderChange(); }
        function removeWeakestSnake() { /* ... Same ... */ if (snakes.length <= MIN_SNAKES) return; let weakestSnake = null; let weakestLength = Infinity; let weakestIndex = -1; for (let i = 0; i < snakes.length; i++) { const len = snakes[i].segments.length; if (len < weakestLength) { weakestLength = len; weakestSnake = snakes[i]; weakestIndex = i; } } if (weakestSnake) { weakestSnake.segments.forEach(segment => gameWorld.remove(segment.mesh)); snakes.splice(weakestIndex, 1); console.log(`Removed Snake: ${weakestSnake.name} (ID: ${weakestSnake.id})`); addLogMessage(`👋 ${weakestSnake.name} was removed.`, "death"); updateInfo(); checkForLeaderChange(); } }
        function addSnakeSegment(snakeData, position, isHead = false) { /* ... Same (BoxGeometry, achievement log fix) ... */ const segmentSize = GRID_SIZE * 0.9; const geometry = new THREE.BoxGeometry(segmentSize, segmentSize, segmentSize); const color = isHead ? snakeData.headColor : snakeData.color; const emissiveColor = isHead ? snakeData.headColor : 0x000000; const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.1, emissive: emissiveColor, emissiveIntensity: isHead ? 0.6 : 0, transparent: false, opacity: 1 }); const mesh = new THREE.Mesh(geometry, material); mesh.position.copy(position); mesh.castShadow = true; mesh.receiveShadow = false; gameWorld.add(mesh); const segment = { mesh: mesh, targetPosition: position.clone() }; if (isHead) snakeData.segments.unshift(segment); else snakeData.segments.push(segment); const currentLength = snakeData.segments.length; if (!isHead && currentLength > 3 && currentLength > snakeData.lastAchievementLength && currentLength % LENGTH_ACHIEVEMENT_INTERVAL === 0) { addLogMessage(`⭐ ${snakeData.name} reached length ${currentLength}!`, "achievement"); snakeData.lastAchievementLength = currentLength; checkForLeaderChange(); } }

        // --- Food Management ---
        function manageFoodCount() { while (foods.length < currentTargetFoodCount) { createAndPlaceFood(false); } }
        function createAndPlaceFood(isPoison = false) { /* ... Same ... */ const geometry = new THREE.IcosahedronGeometry(GRID_SIZE * 0.5, 1); const color = isPoison ? POISON_COLOR : FOOD_COLOR; const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.1, metalness: 0.0, emissive: color, emissiveIntensity: 1.5 }); const newFoodMesh = new THREE.Mesh(geometry, material); newFoodMesh.castShadow = true; newFoodMesh.receiveShadow = false; newFoodMesh.userData.isPoison = isPoison; let foodPos; let collision; const maxAttempts = 250; let attempts = 0; const allObstacles = foods.slice(); snakes.forEach(s => allObstacles.push(...s.segments)); do { collision = false; const range = WORLD_SIZE / GRID_SIZE; const gridX = Math.floor(Math.random() * range) - Math.floor(range / 2); const gridY = Math.floor(Math.random() * range) - Math.floor(range / 2); const gridZ = Math.floor(Math.random() * range) - Math.floor(range / 2); foodPos = new THREE.Vector3( gridX * GRID_SIZE + GRID_SIZE / 2, gridY * GRID_SIZE + GRID_SIZE / 2, gridZ * GRID_SIZE + GRID_SIZE / 2 ); for (const obstacle of allObstacles) { const checkPos = obstacle.isMesh ? obstacle.position : obstacle.targetPosition; if (checkPos.distanceToSquared(foodPos) < (GRID_SIZE * 0.9)**2) { collision = true; break; } } attempts++; } while (collision && attempts < maxAttempts); if (attempts >= maxAttempts) { console.warn(`Could not place ${isPoison ? 'poisoned' : 'normal'} food without collision!`); foodPos = new THREE.Vector3(GRID_SIZE*(Math.random()-0.5)*3, GRID_SIZE*(Math.random()-0.5)*3, GRID_SIZE*(Math.random()-0.5)*3); } newFoodMesh.position.copy(foodPos); gameWorld.add(newFoodMesh); foods.push(newFoodMesh); updateInfo(); if (isPoison) { triggerFocusPause(newFoodMesh); addLogMessage("🧪 Poison fruit appeared!", "poison"); } }
        function spawnPoisonedFruit() { /* ... Same ... */ if (isGameOver || isPausedForFocus) return; console.log("Spawning poisoned fruit!"); createAndPlaceFood(true); }

        // --- AI Logic ---
        function calculateAIMove(currentSnakeData) { /* ... Same (unaware of poison, diverse target) ... */ if (foods.length === 0 || currentSnakeData.segments.length === 0) { return currentSnakeData.direction.clone(); } const headPos = currentSnakeData.segments[0].targetPosition; let foodDistances = foods.map(foodItem => ({ food: foodItem, distSq: calculateWrappedDistanceSq(headPos, foodItem.position, WORLD_SIZE) })).sort((a, b) => a.distSq - b.distSq); let targetFood0 = foodDistances[0]?.food; let distSqSelfTo0 = foodDistances[0]?.distSq ?? Infinity; let targetFood1 = foodDistances[1]?.food; if (!targetFood0) { return currentSnakeData.direction.clone(); } let targetFoodPos = targetFood0.position; if (targetFood1 && snakes.length > 1) { let minDistSqOthersToTarget0 = Infinity; for (const otherSnake of snakes) { if (otherSnake.id === currentSnakeData.id || otherSnake.segments.length === 0) continue; const otherHeadPos = otherSnake.segments[0].targetPosition; minDistSqOthersToTarget0 = Math.min(minDistSqOthersToTarget0, calculateWrappedDistanceSq(otherHeadPos, targetFood0.position, WORLD_SIZE)); } const competitionThreshold = 0.8; if (minDistSqOthersToTarget0 < distSqSelfTo0 * competitionThreshold) { targetFoodPos = targetFood1.position; } } const directions = [ new THREE.Vector3(GRID_SIZE, 0, 0), new THREE.Vector3(-GRID_SIZE, 0, 0), new THREE.Vector3(0, GRID_SIZE, 0), new THREE.Vector3(0, -GRID_SIZE, 0), new THREE.Vector3(0, 0, GRID_SIZE), new THREE.Vector3(0, 0, -GRID_SIZE) ]; const oppositeDirection = currentSnakeData.direction.clone().negate(); const possibleDirs = directions.filter(dir => !dir.equals(oppositeDirection)); let bestDir = null; let minTargetDistSq = Infinity; let foundValidMove = false; let potentialMoves = []; const combinedObstacles = currentSnakeData.segments.slice(1); snakes.forEach(otherSnake => { if (otherSnake.id !== currentSnakeData.id) { combinedObstacles.push(...otherSnake.segments); } }); for (const potentialDir of possibleDirs) { const potentialHeadPos = headPos.clone().add(potentialDir); wrapVector(potentialHeadPos); let collision = false; for (let i = 0; i < combinedObstacles.length; i++) { if (potentialHeadPos.distanceToSquared(combinedObstacles[i].targetPosition) < (GRID_SIZE * 0.8)**2) { collision = true; break; } } if (!collision) { const distSqToTarget = calculateWrappedDistanceSq(potentialHeadPos, targetFoodPos, WORLD_SIZE); potentialMoves.push({ dir: potentialDir, distSq: distSqToTarget, pos: potentialHeadPos }); if (distSqToTarget < minTargetDistSq) { minTargetDistSq = distSqToTarget; bestDir = potentialDir; foundValidMove = true; } } } if (foundValidMove) { const forwardPos = headPos.clone().add(currentSnakeData.direction); wrapVector(forwardPos); const isForwardValid = potentialMoves.some(m => m.dir.equals(currentSnakeData.direction)); if (isForwardValid) { const forwardDistSq = calculateWrappedDistanceSq(forwardPos, targetFoodPos, WORLD_SIZE); if (forwardDistSq <= minTargetDistSq * 1.1) { bestDir = currentSnakeData.direction.clone(); } } return bestDir.clone(); } else { if (potentialMoves.length > 0) { return potentialMoves[0].dir.clone(); } else { return currentSnakeData.direction.clone(); } } }

        // --- Helpers ---
        function wrapAround(value, halfSize) { /* ... Same ... */ const size = halfSize * 2; const centerOffset = GRID_SIZE / 2; const tolerance = 0.01; if (value >= halfSize - centerOffset / 2 + tolerance) return -halfSize + centerOffset; if (value < -halfSize + centerOffset / 2 - tolerance) return halfSize - centerOffset; return value; }
        function wrapVector(vector) { /* ... Same ... */ vector.x = wrapAround(vector.x, WORLD_SIZE_HALF); vector.y = wrapAround(vector.y, WORLD_SIZE_HALF); vector.z = wrapAround(vector.z, WORLD_SIZE_HALF); }
        function calculateWrappedDistanceSq(pos1, pos2, worldFullSize) { /* ... Same ... */ let dx = Math.abs(pos1.x - pos2.x); let dy = Math.abs(pos1.y - pos2.y); let dz = Math.abs(pos1.z - pos2.z); const halfSize = worldFullSize / 2; if (dx > halfSize) dx = worldFullSize - dx; if (dy > halfSize) dy = worldFullSize - dy; if (dz > halfSize) dz = worldFullSize - dz; return dx * dx + dy * dy + dz * dz; }

        // --- Core Update Logic ---
        function updateSnakeState(snakeData) { /* ... Same ... */ if (isGameOver || snakeData.segments.length === 0 || snakeData.dyingState.active) return true; snakeData.nextDirection.copy(calculateAIMove(snakeData)); snakeData.direction.copy(snakeData.nextDirection); const head = snakeData.segments[0]; const newHeadPos = head.targetPosition.clone().add(snakeData.direction); wrapVector(newHeadPos); for (let i = 1; i < snakeData.segments.length; i++) { if (newHeadPos.distanceToSquared(snakeData.segments[i].targetPosition) < (GRID_SIZE * 0.7)**2) { handleCrash(snakeData); return false; } } for (const otherSnake of snakes) { if (otherSnake.id === snakeData.id || otherSnake.dyingState.active) continue; for (let i = 0; i < otherSnake.segments.length; i++) { if (newHeadPos.distanceToSquared(otherSnake.segments[i].targetPosition) < (GRID_SIZE * 0.8)**2) { handleCrash(snakeData); return false; } } } let ateFood = false; let atePoison = false; let eatenFoodIndex = -1; let eatenFoodMesh = null; for (let i = 0; i < foods.length; i++) { const foodItem = foods[i]; if (newHeadPos.distanceToSquared(foodItem.position) < (GRID_SIZE * 0.8)**2) { if (foodItem.userData.isPoison) { atePoison = true; } else { ateFood = true; } eatenFoodIndex = i; eatenFoodMesh = foodItem; triggerParticleExplosion(eatenFoodMesh.position); break; } } if (atePoison && eatenFoodMesh) { addLogMessage(`☠️ ${snakeData.name} ate poison!`, "death"); handlePoisonDeath(snakeData); gameWorld.remove(eatenFoodMesh); foods.splice(eatenFoodIndex, 1); manageFoodCount(); return false; } else if (ateFood && eatenFoodMesh) { gameWorld.remove(eatenFoodMesh); foods.splice(eatenFoodIndex, 1); manageFoodCount(); } const tailPosition = snakeData.segments[snakeData.segments.length - 1].targetPosition.clone(); for (let i = snakeData.segments.length - 1; i > 0; i--) { snakeData.segments[i].targetPosition.copy(snakeData.segments[i - 1].targetPosition); } head.targetPosition.copy(newHeadPos); if (ateFood) { addSnakeSegment(snakeData, tailPosition, false); } return true; }

        // --- Handle Crash / Game Over ---
        function handleCrash(crashedSnakeData) { /* ... Same ... */ if (crashedSnakeData.dyingState.active) return; console.log(`Snake ${crashedSnakeData.name} (${crashedSnakeData.id}) crashed!`); addLogMessage(`💥 ${crashedSnakeData.name} crashed!`, "death"); crashedSnakeData.segments.forEach(segment => gameWorld.remove(segment.mesh)); const crashedIndex = snakes.findIndex(s => s.id === crashedSnakeData.id); if (crashedIndex > -1) { snakes.splice(crashedIndex, 1); } checkGameOverCondition(); checkForLeaderChange(); updateInfo(); }
        function handlePoisonDeath(snakeData) { /* ... Same ... */ if (snakeData.dyingState.active) return; snakeData.dyingState.active = true; snakeData.dyingState.timer = 0; isSlowMotionActive = true; slowMotionTimer = 0; isCameraFocusing = true; focusedSnakeId = snakeData.id; snakeData.segments.forEach(segment => { segment.mesh.material.transparent = true; }); if (autoCameraEnabled) { controls.enabled = false; } }
        function updatePoisonDeathEffects(deltaTime) { /* ... Same ... */ const snakesToRemove = []; for (let i = snakes.length - 1; i >= 0; i--) { const snake = snakes[i]; if (snake.dyingState.active) { snake.dyingState.timer += deltaTime * 1000; const t = Math.min(1.0, snake.dyingState.timer / snake.dyingState.duration); const smooth_t = smoothStep(t); const scale = 1.0 - smooth_t; snake.segments.forEach(segment => { segment.mesh.material.opacity = 1.0 - smooth_t; segment.mesh.scale.setScalar(Math.max(0.01, scale)); }); if (t >= 1.0) { snakesToRemove.push(i); if (snake.id === focusedSnakeId) { isCameraFocusing = false; focusedSnakeId = -1; if(autoCameraEnabled) switchCameraMode(); } } } } for (const index of snakesToRemove.sort((a,b) => b-a)) { const removedSnake = snakes[index]; console.log(`Snake ${removedSnake.name} (${removedSnake.id}) vanished.`); addLogMessage(`👻 ${removedSnake.name} vanished.`, "death"); removedSnake.segments.forEach(segment => gameWorld.remove(segment.mesh)); snakes.splice(index, 1); } if (snakesToRemove.length > 0) { checkGameOverCondition(); checkForLeaderChange(); updateInfo(); } }
        function checkGameOverCondition() { /* ... Same ... */ if (!isGameOver && (snakes.length < MIN_SNAKES || snakes.length < 2)) { isGameOver = true; if (snakes.length === 1) { const winner = snakes[0]; gameOverMessage = `${winner.name} Wins!`; gameOverElement.style.color = `#${winner.headColor.toString(16).padStart(6, '0')}`; addLogMessage(`🏆 ${winner.name} is the winner!`, "achievement"); } else { gameOverMessage = `Game Over!`; gameOverElement.style.color = '#f00'; addLogMessage(`🛑 Game Over!`, "death"); } gameOverElement.innerHTML = `${gameOverMessage}<br><span>Click to Restart</span>`; gameOverElement.style.display = 'block'; controls.enabled = false; isSlowMotionActive = false; isCameraFocusing = false; switchCameraMode('manual'); } }
        function checkForLeaderChange() { /* ... Same ... */ if (snakes.length < 1 || isGameOver) { currentLeaderId = -1; return; } const sortedSnakes = [...snakes].sort((a, b) => b.segments.length - a.segments.length); const newLeader = sortedSnakes[0]; if (newLeader.id !== currentLeaderId) { if (currentLeaderId !== -1) { addLogMessage(`👑 ${newLeader.name} takes the lead!`, "lead"); } currentLeaderId = newLeader.id; } }

        // --- Rendering Updates ---
        function updateSnakeMeshes(deltaTime) { /* ... Same ... */ const interpFactor = Math.min(1, deltaTime / (GAME_SPEED_MS / 1000) * 6); snakes.forEach(snake => { snake.segments.forEach(segment => { segment.mesh.position.lerp(segment.targetPosition, interpFactor); }); }); }

        // --- Particles ---
        function setupParticles() { /* ... Same ... */ const geometry = new THREE.BufferGeometry(); const vertices = []; for (let i = 0; i < PARTICLE_COUNT; i++) { vertices.push(0, 0, 0); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); particleMaterial = new THREE.PointsMaterial({ color: FOOD_COLOR, size: 0.2, transparent: true, opacity: 1.0, depthWrite: false, blending: THREE.AdditiveBlending }); particles = new THREE.Points(geometry, particleMaterial); particles.visible = false; particles.userData.velocities = []; particles.userData.life = 0; particles.userData.maxLife = 0.6; scene.add(particles); }
        function triggerParticleExplosion(worldPosition) { /* ... Same ... */ const posAttribute = particles.geometry.attributes.position; particles.userData.velocities = []; for (let i = 0; i < PARTICLE_COUNT; i++) { posAttribute.setXYZ(i, 0, 0, 0); const velocity = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)); velocity.normalize().multiplyScalar(Math.random() * PARTICLE_SPEED); particles.userData.velocities.push(velocity); } particles.position.copy(worldPosition); posAttribute.needsUpdate = true; particles.visible = true; particleMaterial.opacity = 1.0; particles.userData.life = 0; }
        function updateParticles(deltaTime) { /* ... Same ... */ if (!particles || !particles.visible) return; particles.userData.life += deltaTime; if (particles.userData.life > particles.userData.maxLife) { particles.visible = false; return; } const posAttribute = particles.geometry.attributes.position; const velocities = particles.userData.velocities; for (let i = 0; i < PARTICLE_COUNT; i++) { const x = posAttribute.getX(i) + velocities[i].x * deltaTime; const y = posAttribute.getY(i) + velocities[i].y * deltaTime; const z = posAttribute.getZ(i) + velocities[i].z * deltaTime; posAttribute.setXYZ(i, x, y, z); velocities[i].multiplyScalar(0.98); velocities[i].y -= 1.5 * deltaTime; } posAttribute.needsUpdate = true; particleMaterial.opacity = 1.0 - (particles.userData.life / particles.userData.maxLife)**2; }

        // --- Poison Focus Pause ---
        function triggerFocusPause(poisonMesh) { /* ... Same ... */ if (isPausedForFocus || isReturningFromFocus || isGameOver) return; console.log("Triggering focus pause on poison fruit."); isPausedForFocus = true; focusPauseTimer = 0; focusTargetMesh = poisonMesh; cameraBeforeFocusPos.copy(camera.position); cameraBeforeFocusTarget.copy(controls.target); cameraModeBeforeFocus = currentCameraMode; autoCamEnabledBeforeFocus = autoCameraEnabled; isCameraTransitioning = false; autoCameraEnabled = false; controls.enabled = false; isCameraFocusing = false; focusedSnakeId = -1; }

        // --- Camera Effect Logic ---
        function switchCameraMode(newMode = null) { /* ... Same ... */ let nextMode = newMode; if (autoCameraEnabled && !nextMode) { const availableModes = CAMERA_MODES.filter(mode => mode !== currentCameraMode && (mode !== 'fps' || snakes.length > 0)); nextMode = availableModes[Math.floor(Math.random() * availableModes.length)] || 'orbit'; } else if (!autoCameraEnabled) { nextMode = 'manual'; } else if (!nextMode) { nextMode = 'orbit'; } if (nextMode === currentCameraMode && !isCameraTransitioning) { cameraModeTimer = 0; cameraModeDuration = CAMERA_MODE_DURATION_BASE + (Math.random() * CAMERA_MODE_DURATION_RANDOM * 2) - CAMERA_MODE_DURATION_RANDOM; return; } if (nextMode === currentCameraMode && isCameraTransitioning) return; console.log("Switching camera mode to:", nextMode); cameraPreTransitionPos.copy(camera.position); cameraPreTransitionTarget.copy(controls.target); currentCameraMode = nextMode; cameraModeTimer = 0; cameraModeDuration = CAMERA_MODE_DURATION_BASE + (Math.random() * CAMERA_MODE_DURATION_RANDOM * 2) - CAMERA_MODE_DURATION_RANDOM; isCameraTransitioning = true; cameraTransitionTimer = 0; const orbitRadiusFactor = 1.8 + Math.random() * 0.4; const baseHeightFactor = 0.8; cameraTargetLookAt.set(0, 0, 0); switch (currentCameraMode) { case 'orbit': case 'bRoll': cameraEffectData.orbitSpeed = (currentCameraMode === 'orbit' ? 0.08 : 0.02) + Math.random() * 0.04; const startAngle = totalTime * cameraEffectData.orbitSpeed; const startOrbitRadius = WORLD_SIZE_HALF * orbitRadiusFactor; cameraTargetPosition.set( startOrbitRadius * Math.cos(startAngle), WORLD_SIZE_HALF * 0.9 + Math.sin(startAngle * 0.7) * WORLD_SIZE_HALF * 0.7, startOrbitRadius * Math.sin(startAngle) ); break; case 'panX': case 'panZ': const panDistFactor = 1.6; if (currentCameraMode === 'panX') { cameraEffectData.startPos.set(-WORLD_SIZE_HALF * panDistFactor, WORLD_SIZE_HALF * baseHeightFactor, 0); cameraEffectData.endPos.set(WORLD_SIZE_HALF * panDistFactor, WORLD_SIZE_HALF * baseHeightFactor * 1.2, 0); } else { cameraEffectData.startPos.set(0, WORLD_SIZE_HALF * baseHeightFactor * 1.2, -WORLD_SIZE_HALF * panDistFactor); cameraEffectData.endPos.set(0, WORLD_SIZE_HALF * baseHeightFactor, WORLD_SIZE_HALF * panDistFactor); } cameraTargetPosition.copy(cameraEffectData.startPos); break; case 'zoomInOut': cameraEffectData.startDist = WORLD_SIZE_HALF * (orbitRadiusFactor * 0.7); cameraEffectData.endDist = WORLD_SIZE_HALF * (orbitRadiusFactor * 1.4); if (Math.random() < 0.5) { [cameraEffectData.startDist, cameraEffectData.endDist] = [cameraEffectData.endDist, cameraEffectData.startDist]; } const zoomAngle = totalTime * 0.05; cameraTargetPosition.set(cameraEffectData.startDist * Math.cos(zoomAngle), WORLD_SIZE_HALF * (0.6), cameraEffectData.startDist * Math.sin(zoomAngle)); cameraEffectData.currentDist = cameraEffectData.startDist; break; case 'flyBy': const flybyDistFactor = 1.5; cameraEffectData.startPos.set( WORLD_SIZE_HALF * flybyDistFactor * (Math.random() < 0.5 ? 1 : -1), WORLD_SIZE_HALF * (0.4 + Math.random() * 0.8), WORLD_SIZE_HALF * flybyDistFactor * (Math.random() < 0.5 ? 1 : -1) ); cameraEffectData.endPos.set( -cameraEffectData.startPos.x * (0.8 + Math.random()*0.4), WORLD_SIZE_HALF * (0.4 + Math.random() * 0.8), -cameraEffectData.startPos.z * (0.8 + Math.random()*0.4) ); cameraTargetPosition.copy(cameraEffectData.startPos); break; case 'fps': if (snakes.length > 0) { const oldTargetSnakeId = cameraEffectData.targetSnakeId; const availableSnakes = snakes.filter(s => s.id !== oldTargetSnakeId); const targetSnake = availableSnakes.length > 0 ? availableSnakes[Math.floor(Math.random() * availableSnakes.length)] : snakes[Math.floor(Math.random() * snakes.length)]; cameraEffectData.targetSnakeId = targetSnake.id; if (targetSnake.segments.length > 0) { _snakeHeadPos.copy(targetSnake.segments[0].targetPosition); _snakeDir.copy(targetSnake.direction).normalize(); const offsetDist = -GRID_SIZE * 2.5; const heightOffset = GRID_SIZE * 1.5; cameraTargetPosition.copy(_snakeHeadPos).addScaledVector(_snakeDir, offsetDist).add(new THREE.Vector3(0, heightOffset, 0)); cameraTargetLookAt.copy(_snakeHeadPos).addScaledVector(_snakeDir, GRID_SIZE * 5); } else { switchCameraMode('orbit'); return; } } else { switchCameraMode('orbit'); return; } break; case 'manual': cameraTargetPosition.copy(cameraPreTransitionPos); cameraTargetLookAt.copy(cameraPreTransitionTarget); break; } if (currentCameraMode === 'manual') { autoCameraEnabled = false; controls.enabled = true; } else { autoCameraEnabled = true; controls.enabled = false; } updateInfo(); }
        function smoothStep(x) { return x * x * (3 - 2 * x); }
        function updateAutoCamera(deltaTime) { /* ... Same ... */ const targetPos = _camPos; const targetLookAt = _camLookAt; if (isCameraTransitioning) { cameraTransitionTimer += deltaTime; const t = Math.min(1.0, cameraTransitionTimer / CAMERA_TRANSITION_DURATION); const smooth_t = smoothStep(t); camera.position.lerpVectors(cameraPreTransitionPos, cameraTargetPosition, smooth_t); targetLookAt.lerpVectors(cameraPreTransitionTarget, cameraTargetLookAt, smooth_t); camera.lookAt(targetLookAt); controls.target.copy(targetLookAt); if (t >= 1.0) { isCameraTransitioning = false; cameraModeTimer = 0; camera.position.copy(cameraTargetPosition); camera.lookAt(cameraTargetLookAt); controls.target.copy(cameraTargetLookAt); console.log("Transition complete for:", currentCameraMode); } } else { cameraModeTimer += deltaTime; if (cameraModeTimer >= cameraModeDuration && autoCameraEnabled && !isGameOver) { switchCameraMode(); return; } const t = Math.min(1.0, cameraModeTimer / cameraModeDuration); const smooth_t = smoothStep(t); targetLookAt.set(0,0,0); switch (currentCameraMode) { case 'orbit': case 'bRoll': const orbitSpeed = cameraEffectData.orbitSpeed; const orbitRadius = WORLD_SIZE_HALF * (1.8 + Math.sin(totalTime * 0.05) * 0.3); targetPos.set( orbitRadius * Math.cos(totalTime * orbitSpeed), WORLD_SIZE_HALF * 0.9 + Math.sin(totalTime * orbitSpeed * 0.6) * WORLD_SIZE_HALF * 0.6, orbitRadius * Math.sin(totalTime * orbitSpeed) ); camera.position.copy(targetPos); break; case 'panX': case 'panZ': targetPos.lerpVectors(cameraEffectData.startPos, cameraEffectData.endPos, smooth_t); camera.position.copy(targetPos); break; case 'zoomInOut': cameraEffectData.currentDist = THREE.MathUtils.lerp(cameraEffectData.startDist, cameraEffectData.endDist, smooth_t); const angle = totalTime * 0.03; targetPos.set( cameraEffectData.currentDist * Math.cos(angle), WORLD_SIZE_HALF * (0.5 + smooth_t * 0.6), cameraEffectData.currentDist * Math.sin(angle) ); camera.position.copy(targetPos); break; case 'flyBy': targetPos.lerpVectors(cameraEffectData.startPos, cameraEffectData.endPos, smooth_t); camera.position.copy(targetPos); const lookAheadRatio = 0.05 + smooth_t * 0.1; targetLookAt.copy(camera.position).lerp(cameraEffectData.endPos, lookAheadRatio); break; case 'fps': const targetSnake = snakes.find(s => s.id === cameraEffectData.targetSnakeId); if (targetSnake && targetSnake.segments.length > 0) { _snakeHeadPos.copy(targetSnake.segments[0].mesh.position); _snakeDir.copy(targetSnake.direction).normalize(); const offsetDist = -GRID_SIZE * 2.0; const heightOffset = GRID_SIZE * 1.2; targetPos.copy(_snakeHeadPos).addScaledVector(_snakeDir, offsetDist).add(new THREE.Vector3(0, heightOffset, 0)); _idealLookAtFPS.copy(_snakeHeadPos).addScaledVector(_snakeDir, GRID_SIZE * 6); const lerpFactorPos = Math.min(1.0, deltaTime * 6.0); camera.position.lerp(targetPos, lerpFactorPos); const lerpFactorLookAt = Math.min(1.0, deltaTime * 3.5); controls.target.lerp(_idealLookAtFPS, lerpFactorLookAt); camera.lookAt(controls.target); targetLookAt.copy(controls.target); } else { switchCameraMode('orbit'); return; } break; } if (currentCameraMode !== 'fps' && currentCameraMode !== 'flyBy') { if (controls.target.lengthSq() > 0.001) { controls.target.lerp(targetLookAt, Math.min(1.0, deltaTime * 5.0)); } else { controls.target.copy(targetLookAt); } camera.lookAt(controls.target); } camera.updateMatrixWorld(); } }

        // --- Event Handlers & UI ---
        function onWindowResize() { /* ... Same ... */ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function onUtilityKeyDown(event) { // <<-- Corrected C toggle
            const key = event.key.toLowerCase();
            if (key === '1') { setBackgroundDensity('low'); }
            else if (key === '2') { setBackgroundDensity('medium'); }
            else if (key === '3') { setBackgroundDensity('high'); }
            else if (key === 'c') { // Toggle Auto/Manual Camera
                 if (autoCameraEnabled) { switchCameraMode('manual'); }
                 else { autoCameraEnabled = true; switchCameraMode(); } // <<-- Set true first
            }
            else if (key === 'g') { gridVisible = !gridVisible; if (worldGrid) { worldGrid.visible = gridVisible; } updateInfo(); }
            else if (key === 's') { currentCubeSizeIndex = (currentCubeSizeIndex + 1) % CUBE_SIZES.length; resetGame(); }
            else if (key === 'f') { toggleFullscreen(); }
            else if (key === 'k') { randomPoisonEnabled = !randomPoisonEnabled; if(randomPoisonEnabled) lastPoisonSpawnTime = performance.now(); console.log("Random Poison Enabled:", randomPoisonEnabled); updateInfo(); }
            else if (key === ' ' && !isGameOver && !isPausedForFocus) { spawnPoisonedFruit(); event.preventDefault(); }
            else if (!isGameOver) { if (event.key === '+' || event.key === '=') { addSnake(); } else if (event.key === '-' || event.key === '_') { removeWeakestSnake(); } }
         }
        function setBackgroundDensity(level) { /* ... Same ... */ if (!BG_DENSITY_LEVELS[level] || level === currentBgDensityLevel) return; console.log("Setting BG density to:", level); currentBgDensityLevel = level; STAR_COUNT = BG_DENSITY_LEVELS[level].stars; ASTEROID_COUNT = BG_DENSITY_LEVELS[level].asteroids; createSpaceBackground(STAR_COUNT, ASTEROID_COUNT); updateInfo(); }
        function toggleFullscreen() { /* ... Same ... */ if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { console.warn("Fullscreen request failed:", err); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
        function addLogMessage(message, type = "") { /* ... Same ... */ const logEntry = document.createElement('div'); logEntry.className = `logEntry ${type}`; logEntry.innerHTML = message; eventLogElement.insertBefore(logEntry, eventLogElement.firstChild); while (eventLogElement.children.length > MAX_LOG_ENTRIES) { eventLogElement.removeChild(eventLogElement.lastChild); } }
        function updateInfo(fps = 0) { /* ... Added BG Density label ... */ snakes.sort((a, b) => b.segments.length - a.segments.length); let maxLength = 0; snakes.forEach(snake => { maxLength = Math.max(maxLength, snake.segments.length); }); maxLength = Math.max(maxLength, 1); let barsHTML = ""; snakes.forEach(snake => { const relativeLength = (snake.segments.length / maxLength) * 100; barsHTML += `<div class="snake-info" id="snake-bar-${snake.id}"><span class="snake-label" style="color: #${snake.headColor.toString(16).padStart(6, '0')};" title="${snake.name}">${snake.name}:</span><div class="length-bar-container"><div class="length-bar" style="width: ${relativeLength}%; background-color: #${snake.color.toString(16).padStart(6, '0')};"></div></div></div>`; }); snakeBarsWrapper.innerHTML = barsHTML; gameStatusElement.innerHTML = `FPS: ${fps.toFixed(0)}<br>Snakes: ${snakes.length} (+/-)<br>Size: ${WORLD_SIZE} [S]<br>Food Count: ${foods.length}/${currentTargetFoodCount}<br>Poison: ${randomPoisonEnabled ? 'On' : 'Off'} [K] [Space]<br>BG Density: ${BG_DENSITY_LEVELS[currentBgDensityLevel].label} [1/2/3]<br>Cam Mode: ${currentCameraMode} ${isCameraTransitioning ? '(T)' : ''} ${isPausedForFocus ? '(Focus!)': ''} [C]<br>Grid: ${gridVisible ? 'On' : 'Off'} [G]<br>Fullscreen: [F]`; }

        // --- Animation Loop ---
        function animate() { // <<-- Added FPS Cam Slowdown
            requestAnimationFrame(animate); const delta = clock.getDelta(); totalTime += delta; frameDeltaAccumulator += delta;
            if (frameDeltaAccumulator >= MIN_FRAME_TIME) {
                 const now = performance.now();
                 // --- Calculate Time Scale ---
                 let timeScale = 1.0;
                 if (isSlowMotionActive) { // Poison death slow-mo takes priority
                     slowMotionTimer += delta * 1000;
                     if (slowMotionTimer < SLOW_MOTION_DURATION_MS) { timeScale = SLOW_MOTION_FACTOR; }
                     else { isSlowMotionActive = false; }
                 } else if (autoCameraEnabled && currentCameraMode === 'fps' && !isPausedForFocus && !isReturningFromFocus && !isCameraTransitioning) {
                     // Apply FPS camera slowdown *only* if auto cam is on, in FPS mode, and not pausing/returning/transitioning
                     timeScale = FPS_CAMERA_SLOWDOWN_FACTOR;
                 }
                 // ---
                 const effectiveDelta = MIN_FRAME_TIME * timeScale; const rawFrameDelta = MIN_FRAME_TIME; frameDeltaAccumulator -= MIN_FRAME_TIME; frameDeltaAccumulator = Math.min(frameDeltaAccumulator, MIN_FRAME_TIME * 5);

                 // --- Poison Focus Pause Logic ---
                 if (isPausedForFocus) {
                      focusPauseTimer += rawFrameDelta * 1000;
                      if (focusTargetMesh && focusTargetMesh.parent) {
                          const focusDist = WORLD_SIZE_HALF * 0.5 + GRID_SIZE * 3; const focusHeight = WORLD_SIZE_HALF * 0.3;
                          const targetLookAtPos = focusTargetMesh.position;
                          const angleOffset = totalTime * 0.5;
                          _focusPos.copy(targetLookAtPos).add(new THREE.Vector3( Math.sin(angleOffset) * focusDist, focusHeight, Math.cos(angleOffset) * focusDist ));
                          const lerpFactorFocus = Math.min(1.0, rawFrameDelta * 4.0);
                          camera.position.lerp(_focusPos, lerpFactorFocus);
                          controls.target.lerp(targetLookAtPos, lerpFactorFocus);
                          camera.lookAt(controls.target);
                          camera.updateMatrixWorld();
                      } else { console.warn("Focus target mesh lost during pause!"); isPausedForFocus = false; focusTargetMesh = null; isReturningFromFocus = true; cameraTransitionTimer = 0; }
                      if (focusPauseTimer >= POISON_FOCUS_DURATION_MS) { console.log("Focus pause finished. Returning camera."); isPausedForFocus = false; focusTargetMesh = null; isReturningFromFocus = true; cameraTransitionTimer = 0; }
                 }
                 // --- Return From Focus Transition ---
                 else if (isReturningFromFocus) {
                      cameraTransitionTimer += rawFrameDelta; const t = Math.min(1.0, cameraTransitionTimer / CAMERA_TRANSITION_DURATION); const smooth_t = smoothStep(t);
                      camera.position.lerpVectors(camera.position, cameraBeforeFocusPos, smooth_t); _camLookAt.lerpVectors(controls.target, cameraBeforeFocusTarget, smooth_t); camera.lookAt(_camLookAt); controls.target.copy(_camLookAt);
                      if (t >= 1.0) { console.log("Return from focus complete."); isReturningFromFocus = false; autoCameraEnabled = autoCamEnabledBeforeFocus; switchCameraMode(cameraModeBeforeFocus); controls.enabled = !autoCameraEnabled; }
                 }
                 // --- Normal Game Simulation & Camera Update ---
                 else if (!isGameOver) {
                      gameTime += effectiveDelta; // Use scaled delta for game time
                      gameWorld.rotation.y += WORLD_ROTATION_SPEED * effectiveDelta; // Use scaled delta
                      gameWorld.rotation.x += WORLD_ROTATION_SPEED * 0.1 * effectiveDelta; // Use scaled delta
                      if (randomPoisonEnabled && now - lastPoisonSpawnTime > RANDOM_POISON_INTERVAL_MS) { if (Math.random() < RANDOM_POISON_SPAWN_CHANCE) { spawnPoisonedFruit(); lastPoisonSpawnTime = now; } else { lastPoisonSpawnTime = now; } }
                      if (gameTime * 1000 >= GAME_SPEED_MS) { for (let i = snakes.length - 1; i >= 0; i--) { if (!isGameOver) { updateSnakeState(snakes[i]); } else { break; } } gameTime = 0; }
                      updatePoisonDeathEffects(delta); // Use raw delta
                      updateSnakeMeshes(effectiveDelta); // Use scaled delta
                      updateParticles(effectiveDelta); // Use scaled delta
                      if (starField) starField.rotation.y += 0.00005 * effectiveDelta * 60; // Use scaled delta
                      if (asteroidGroup) { asteroidGroup.rotation.y += 0.0001 * effectiveDelta * 60; asteroidGroup.children.forEach(asteroid => { asteroid.rotation.x += asteroid.userData.rotationSpeed.x * effectiveDelta * 60; asteroid.rotation.y += asteroid.userData.rotationSpeed.y * effectiveDelta * 60; asteroid.rotation.z += asteroid.userData.rotationSpeed.z * effectiveDelta * 60; }); } // Use scaled delta
                      if (autoCameraEnabled && !isCameraFocusing) { updateAutoCamera(effectiveDelta); } // Pass scaled delta to camera updates
                      else if (!autoCameraEnabled) { controls.update(); } // Manual control uses its own internal timing
                 }
                 // --- Game Over State ---
                 else { /* ... Use effectiveDelta for rotations/interpolation ... */ gameWorld.rotation.y += (WORLD_ROTATION_SPEED / 4) * effectiveDelta; gameWorld.rotation.x += (WORLD_ROTATION_SPEED * 0.1 / 4) * effectiveDelta; updateSnakeMeshes(effectiveDelta * 0.5); if (starField) starField.rotation.y += 0.00005 * effectiveDelta * 60; if (asteroidGroup) { asteroidGroup.rotation.y += 0.0001 * effectiveDelta * 60; asteroidGroup.children.forEach(asteroid => { asteroid.rotation.x += asteroid.userData.rotationSpeed.x * effectiveDelta * 60; asteroid.rotation.y += asteroid.userData.rotationSpeed.y * effectiveDelta * 60; asteroid.rotation.z += asteroid.userData.rotationSpeed.z * effectiveDelta * 60; }); } if (!autoCameraEnabled) controls.update(); }

                 composer.render();
                 frameCount++; if (now >= lastFPSTime + 1000) { const currentFPS = (frameCount * 1000) / (now - lastFPSTime); updateInfo(currentFPS); lastFPSTime = now; frameCount = 0; }
            } // End FPS Limiter
         } // End animate

        // --- Start ---
        init();

    </script>
</body>
</html>